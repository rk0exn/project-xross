use std::ffi::c_void;
use std::sync::OnceLock;

pub use xross_macros::{
    XrossClass, xross_class, xross_function, xross_function_dsl, xross_methods,
};

/// A standard result structure for FFI calls.
/// Used to pass success/failure status and a pointer to the result or error message.
#[repr(C)]
pub struct XrossResult {
    /// True if the operation was successful.
    pub is_ok: bool,
    /// Pointer to the result data or an error message.
    pub ptr: *mut c_void,
}

unsafe impl Send for XrossResult {}
unsafe impl Sync for XrossResult {}

/// A handle to an asynchronous task being executed in Rust.
#[repr(C)]
pub struct XrossTask {
    /// Pointer to the internal task state (the Future).
    pub task_ptr: *mut c_void,
    /// Function to poll the task.
    pub poll_fn: unsafe extern "C" fn(*mut c_void) -> XrossResult,
    /// Function to drop the task state.
    pub drop_fn: unsafe extern "C" fn(*mut c_void),
}

unsafe impl Send for XrossTask {}
unsafe impl Sync for XrossTask {}

#[cfg(feature = "tokio")]
static RUNTIME: OnceLock<tokio::runtime::Runtime> = OnceLock::new();

#[cfg(feature = "tokio")]
fn get_runtime() -> &'static tokio::runtime::Runtime {
    RUNTIME.get_or_init(|| {
        tokio::runtime::Builder::new_multi_thread()
            .enable_all()
            .build()
            .expect("Failed to create Tokio runtime")
    })
}

#[cfg(feature = "tokio")]
pub fn xross_spawn_task<F, T>(future: F, mapper: fn(T) -> XrossResult) -> XrossTask
where
    F: std::future::Future<Output = T> + Send + 'static,
    T: Send + 'static,
{
    let rt = get_runtime();
    let (tx, rx) = tokio::sync::mpsc::unbounded_channel();

    rt.spawn(async move {
        let res = future.await;
        let _ = tx.send(mapper(res));
    });

    unsafe extern "C" fn poll_task(ptr: *mut c_void) -> XrossResult {
        let rx = unsafe { &mut *(ptr as *mut tokio::sync::mpsc::UnboundedReceiver<XrossResult>) };
        match rx.try_recv() {
            Ok(res) => res,
            Err(tokio::sync::mpsc::error::TryRecvError::Empty) => {
                XrossResult { is_ok: true, ptr: std::ptr::null_mut() }
            } // Still running
            Err(_) => XrossResult { is_ok: false, ptr: std::ptr::null_mut() }, // Channel closed
        }
    }

    unsafe extern "C" fn drop_task(ptr: *mut c_void) {
        let _ =
            unsafe { Box::from_raw(ptr as *mut tokio::sync::mpsc::UnboundedReceiver<XrossResult>) };
    }

    XrossTask {
        task_ptr: Box::into_raw(Box::new(rx)) as *mut c_void,
        poll_fn: poll_task,
        drop_fn: drop_task,
    }
}

/// A marker trait for types that can be bridged between Rust and JVM.
/// Implementation is typically generated by the `xross_class` or `XrossClass` macros.
pub trait XrossClass {
    /// Returns the JSON metadata for the type.
    fn xross_layout() -> String;
}

/// Frees a string allocated by Rust that was passed to the JVM.
///
/// # Safety
///
/// This function is unsafe because it takes a raw pointer and deallocates it.
/// The pointer must have been created by `CString::into_raw`.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn xross_free_string(ptr: *mut std::ffi::c_char) {
    if !ptr.is_null() {
        unsafe {
            let _ = std::ffi::CString::from_raw(ptr);
        }
    }
}
